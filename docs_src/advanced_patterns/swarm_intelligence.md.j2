# SOE Advanced Patterns: Swarm Intelligence

## Introduction

Most agent frameworks rely on **conversation** (text back-and-forth). SOE relies on **signals**. This is much more efficient for coordinating multiple agents.

Swarm patterns enable:
- **Voting/Consensus** — Multiple agents vote, deterministic logic tallies
- **Jury Systems** — Parallel analysis with majority decision
- **Bidding/Auctions** — Agents compete via signal-based mechanisms

**Note**: Many swarm patterns leverage the **accumulated context** feature. For simpler fan-out and aggregation patterns, see [Fan-Out, Fan-In & Aggregations](guide_fanout_and_aggregations.md).

---

## Pattern 1: Simple Consensus

Check if a threshold is met using deterministic routing.

### The Workflow

```yaml
{{ extract_yaml('tests/test_cases/workflows/advanced_swarm.py', 'simple_consensus') }}
```

### How It Works

1. Context contains `approve_count` and `threshold`
2. Router emits `CONSENSUS_REACHED` if threshold met
3. Router emits `CONSENSUS_FAILED` otherwise

**No LLM needed** — pure conditional logic handles the decision.

### Usage

```python
execution_id = orchestrate(
    config=simple_consensus,
    initial_workflow_name="consensus_workflow",
    initial_signals=["START"],
    initial_context={
        "approve_count": 5,
        "threshold": 3,
    },
    ...
)
# Result: CONSENSUS_REACHED signal emitted
```

---

## Pattern 2: Multi-Voter Tallying

Multiple voters provide input, router tallies the results.

### The Workflow

```yaml
{{ extract_yaml('tests/test_cases/workflows/advanced_swarm.py', 'deterministic_voting') }}
```

### How It Works

1. Context contains a list of votes: `[{voter: "A", vote: "approve"}, ...]`
2. Router uses Jinja2 to count approvals
3. Emits `APPROVED` if majority approve, `REJECTED` otherwise

### The Jinja2 Magic

The condition uses Jinja2 filters to count:

```jinja
{% raw %}{{ (context.votes | selectattr('vote', 'equalto', 'approve') | list | length) >= 2 }}{% endraw %}
```

This:
1. Filters votes where `vote == 'approve'`
2. Counts them
3. Compares to threshold

---

## Pattern 3: LLM-Based Voting (Full Swarm)

For real swarm intelligence, multiple LLM nodes can vote in parallel.

### The Workflow

```yaml
{{ extract_yaml('tests/test_cases/workflows/advanced_swarm.py', 'voting_workflow') }}
```

### How It Works

1. `ANALYZE` signal triggers all three voters **in parallel**
2. Each voter outputs to their own field (`vote_1`, `vote_2`, `vote_3`)
3. Each voter emits `VOTE_CAST`
4. `TallyVotes` router triggers on each `VOTE_CAST`
5. When all votes present, router emits final decision

**Key Insight**: The router runs multiple times but only emits the final signal when all votes are available (Jinja2 conditions check for all fields).

---

## Why Signals Beat Conversation

| Approach | Coordination Cost | Speed |
|----------|-------------------|-------|
| Conversation | Parse N paragraphs per round | Slow |
| Signals | Count N signal emissions | Fast |

For 12 agents voting, conversation requires parsing 12 text responses. Signals require counting 12 emissions. The signal approach scales to hundreds of agents.

---

## Related Patterns

- [Hybrid Intelligence](hybrid_intelligence.md) — Mix deterministic and AI logic
- [Self-Evolving Workflows](self_evolving_workflows.md) — Agents that modify their own workflows
